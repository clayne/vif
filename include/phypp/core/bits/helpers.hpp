#ifndef PHYPP_INCLUDING_CORE_VEC_BITS
#error this file is not meant to be included separately, include "phypp/core/vec.hpp" instead
#endif

namespace phypp {
    // Generic vector type
    template<std::size_t Dim, typename Type>
    struct vec;

namespace meta {

    // Helper to get the vector internal storage type.
    // This is used to avoid std::vector<bool>.
    template<typename T>
    struct dtype {
        using type = T;
    };
    template<>
    struct dtype<bool> {
        using type = char;
    };

    template<typename T>
    using dtype_t = typename dtype<T>::type;

    // Helper to get the decayed data type of a vector
    // vec<D,T>       = T
    // vec<D,T*>      = T
    // vec<D,const T> = T
    template<typename T>
    using rtype_t = typename std::remove_cv<
        typename std::remove_pointer<
            typename std::remove_cv<T>::type
        >::type
    >::type;
}

    // Helper to check if a given type is a generic vector.
namespace impl {
    namespace meta_impl {
        template<typename T>
        struct is_vec_ : public std::false_type {};

        template<std::size_t Dim, typename Type>
        struct is_vec_<vec<Dim,Type>> : public std::true_type {};
    }
}

namespace meta {
    template<typename T>
    using is_vec = impl::meta_impl::is_vec_<typename std::decay<T>::type>;

    // Return the data type of the provided type
    template<typename T>
    struct data_type {
        using type = T;
    };

    template<std::size_t Dim, typename T>
    struct data_type<vec<Dim,T>> {
        using type = T;
    };

    template<typename T>
    using data_type_t = typename data_type<T>::type;

    // Return the dimension of a vector
    template<typename T>
    struct vec_dim;

    template<std::size_t Dim, typename T>
    struct vec_dim<vec<Dim,T>> : std::integral_constant<std::size_t,Dim> {};

    // Helper to match a type to the corresponding vector internal type.
    template<typename T>
    struct vtype {
        using type = T;
    };

    template<>
    struct vtype<char*> {
        using type = std::string;
    };

    template<>
    struct vtype<const char*> {
        using type = std::string;
    };

    template<std::size_t N>
    struct vtype<char[N]> {
        using type = std::string;
    };

    template<typename T>
    using vtype_t = typename vtype<typename std::decay<T>::type>::type;

    // Compute the total number of dimensions generated by a set of arguments (for indexing)
    template<typename T>
    struct dim_index : std::integral_constant<std::size_t, 1> {};
    template<std::size_t N, typename T>
    struct dim_index<std::array<T,N>> : std::integral_constant<std::size_t, N> {};

    template<typename T, typename ... Args>
    struct dim_total : std::integral_constant<std::size_t,
        dim_index<typename std::decay<T>::type>::value + dim_total<Args...>::value> {};

    template<typename T>
    struct dim_total<T> : std::integral_constant<std::size_t,
        dim_index<typename std::decay<T>::type>::value> {};
    }

    // Trait to figure out if type list matches an dimension list
namespace impl {
    namespace meta_impl {
        template<typename T>
        struct is_dim_elem_ : std::is_integral<T> {};

        template<typename T, std::size_t N>
        struct is_dim_elem_<std::array<T,N>> : std::true_type {};
    }
}

namespace meta {
    template<typename T>
    using is_dim_elem = impl::meta_impl::is_dim_elem_<typename std::decay<T>::type>;

    template<typename ... Args>
    struct is_dim_list : std::integral_constant<bool,
        are_all_true<bool_list<is_dim_elem<Args>::value...>>::value> {};

    template<>
    struct is_dim_list<> : std::true_type {};
}

namespace impl {
    namespace meta_impl {
        template<typename TFrom, typename TTo>
        struct vec_implicit_convertible_ : std::is_convertible<TFrom,TTo> {};

        // Implicit conversion to/from bool is disabled
        template<typename TFrom>
        struct vec_implicit_convertible_<TFrom,bool> : std::false_type {};
        template<typename TTo>
        struct vec_implicit_convertible_<bool,TTo> : std::false_type {};
        template<>
        struct vec_implicit_convertible_<bool,bool> : std::true_type{};

        template<typename TFrom, typename TTo>
        struct vec_explicit_convertible_ : std::is_convertible<TFrom,TTo> {};
    }
}

namespace meta {
    // Trait to define if a vector type can be implicitly converted into another
    template<typename TFrom, typename TTo>
    using vec_implicit_convertible = impl::meta_impl::vec_implicit_convertible_<
        typename std::decay<typename std::remove_pointer<TFrom>::type>::type,
        typename std::decay<typename std::remove_pointer<TTo>::type>::type
    >;

    // Trait to define if a vector type can be explicitly converted into another
    template<typename TFrom, typename TTo>
    using vec_explicit_convertible = impl::meta_impl::vec_explicit_convertible_<
        typename std::decay<typename std::remove_pointer<TFrom>::type>::type,
        typename std::decay<typename std::remove_pointer<TTo>::type>::type
    >;

    // Trait to define if a vector type can be converted *only* explicitly into another
    template<typename TFrom, typename TTo>
    using vec_only_explicit_convertible = std::integral_constant<bool,
            vec_explicit_convertible<TFrom,TTo>::value &&
            !vec_implicit_convertible<TFrom, TTo>::value>;
} // end namespace meta

namespace impl {
    // Helpers to reference/dereference variables only when necessary.
    // 'Type' must be the second template argument of the vector from which this
    // value comes, i.e. vec<Dim,Type>.
    template<typename Type, typename T>
    meta::rtype_t<Type>& dref(T& t) {
        return reinterpret_cast<meta::rtype_t<Type>&>(t);
    }
    template<typename Type, typename T>
    const meta::rtype_t<Type>& dref(const T& t) {
        return reinterpret_cast<const meta::rtype_t<Type>&>(t);
    }

    template<typename Type, typename T>
    meta::rtype_t<Type>& dref(T* t) {
        return reinterpret_cast<meta::rtype_t<Type>&>(*t);
    }
    template<typename Type, typename T>
    const meta::rtype_t<Type>& dref(const T* t) {
        return reinterpret_cast<const meta::rtype_t<Type>&>(*t);
    }

    template<typename Type, typename T>
    meta::rtype_t<Type>* ptr(T* t) {
        return reinterpret_cast<meta::rtype_t<Type>*>(t);
    }
    template<typename Type, typename T>
    const meta::rtype_t<Type>* ptr(const T* t) {
        return reinterpret_cast<const meta::rtype_t<Type>*>(t);
    }

    template<typename Type, typename T>
    meta::rtype_t<Type>* ptr(T& t) {
        return reinterpret_cast<meta::rtype_t<Type>*>(&t);
    }
    template<typename Type, typename T>
    const meta::rtype_t<Type>* ptr(const T& t) {
        return reinterpret_cast<const meta::rtype_t<Type>*>(&t);
    }

    // Assign an arbitrary list of values to an array.
    // Supports scalars and other arrays.
    template<std::size_t N, typename T, std::size_t I>
    void set_array_(std::array<T,N>& v, meta::cte_t<I>) {}

    template<std::size_t N, typename T, std::size_t I, typename U, std::size_t M, typename ... Args>
    void set_array_(std::array<T,N>& v, meta::cte_t<I>, const std::array<U,M>& t, Args&& ... args);

    template<std::size_t N, typename T, std::size_t I, typename U, typename ... Args>
    void set_array_(std::array<T,N>& v, meta::cte_t<I>, const U& t, Args&& ... args) {
        v[I] = static_cast<T>(t);
        set_array_(v, meta::cte_t<I+1>{}, std::forward<Args>(args)...);
    }

    template<std::size_t N, typename T, std::size_t I, typename U, std::size_t M, typename ... Args>
    void set_array_(std::array<T,N>& v, meta::cte_t<I>, const std::array<U,M>& t, Args&& ... args) {
        for (uint_t i : range(M)) {
            v[I+i] = static_cast<T>(t[i]);
        }

        set_array_(v, meta::cte_t<I+M>{}, std::forward<Args>(args)...);
    }

    template<std::size_t N, typename T, typename ... Args>
    void set_array(std::array<T,N>& v, Args&& ... args) {
        static_assert(N == meta::dim_total<Args...>::value, "wrong number of elements for this array");
        set_array_(v, meta::cte_t<0>{}, std::forward<Args>(args)...);
    }
} // end namespace impl
} // end namespace phypp
